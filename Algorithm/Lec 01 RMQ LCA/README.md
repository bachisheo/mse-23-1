 
## Дерево отрезков
Это виртуальный тип (не структура данных). Пстроим над отрезком бианрное дерево, каждой вершине будет соответствовать подотрезку. Оно обязательно полное, но листья могут быть не на одном уровне. Дерево такой же высоты, как если бы мы расширили его до степени двойки. 

Способы построить дерево:
1. Дополнить до степени двойки
2. Строить сразу, округляя пополам

s(v) - **канонический** отрезок - отрезок, соответствующей вершине v

*Утверждение*: любой отрезок разбивается на не больше, чем 2log(n) канонических
> Интуиция: Рекурсивно вызываемся от вершины и считаем, что из нижних приходит уже готовый ответ.
```python
def split(v, [l, r]):
    if S(v) == (a, b)
        // case 1
        if r < (a + b)/ 2
            ret r
        if l > (a + b)/ 2
            ret r
        //case 2
        if l < (a + b)/2 < r
            ret min(split(left, right))
```

*Доказательство*: 
1. для произвольной вершины рассмотрим ее поддерево. Как он расположен в дереве? есть 3 варианта
* Целиком лежит в одном из поддеревьев, не касаясь границ -> переходим туда. 1 рекурсивный вызов
* после разделения будет 2 подотрезка, при этом при дальнейшем спуске всегда будем касаться границы и когда весь потомок входит - уже не спускаемся вниз.  
Т.е. если мы касаемся конца отрезка, то полсе этого будет только 1 ветка рекурсии (почему?) 

:
1. Предподсчет: строим дерево с минимумом вершин O(n), т.к. n-1 врешин всего. Каждой вершине нужно приписать отрезок и сравнить два минимума.
2. Запрос1: O(logn) разбиваем входной отрезок на О(logn) канонических. **Для канонического отрезка минимум известен.**
3. Запрос2: O(logn) меняем элемент и чиним путь до корня, глубина ограничена logn

Для каких операций (**ассоциативных**, т.е. моноидов) это все будет работать?
1. Сумма
2. Минимум/ максимум

 # RMQ - range minimal query
 Описание задачи:
 * input: a1..an, l, r
 * $query_1: l, r -> min[a_l ... a_r]$
 * $query_2: i, x -> a_i = x$


 Определение 1: задача с запросами решается за (f(n), g(n)), где f(n) - время предобработки, g(n) - время одного запроса.

 Определение 2: различают статические и динамические запросы
 * динамическое -- элементы меняют свое значение (query_2)
 * статическое -- состояние структуры данных не изменяется 

 ## Динамическое RMQ (O(n), O(log n))
*Теорема 1*: не существует решения за (O(n), o(log n))

Пусть есть массив. 
1. Найдем самый маленький элемент, выпишем его как самый маленький элемент a_i. Запишем его в начало отсортированного массива
2. Меняем его на бесконечность

Если умеем делать запросы за o(log n), то за o(n log n) отсортируем массив, а мы знаем, что это невозможно.

# RSQ - range static query
Дерево сумм $(O(n), O(1))$

1. Полный предподсчет $(O(n^2), O(1))$
> для каждого l считаем минимум для всех возможных r

2. Sparce Table Разреженные таблицы (O(nlogn), O(1))

Предподсчет $O(n\log_n)$
* Для каждого индекса i посчитаем минимум на отрезке длины 1 и запишу в отдельный массив
* То же на отрезке длины 2, 4, 8. Это хранится для каждого i (это соответсвует левой границе отрезка)
* O(n) сравнений за O(logn) итераций (уровней)

Храним в таблице размера  $n\log_n$

Запрос: 
* (r - l + 1) = 2^k - просто возвращаем
* 2^(k-1) < (r - l + 1) < 2^k найдем стпень двойки, которая точно перекрывает середину
* min(a, a) = a для суммы это не работает, должно быть свойство идемпотентности (например, умножаем их числа и проверяем их четность)

# LCA least (lowest) common accesor
Структура: корневое дерево, у вершины есть указатель на родителя.

Запрос: для пары вершин найти наименьшего общего предка (расстояние от которой до корня наибольшее)

## 1. Двоичные подъемы (O(n log n), O(log n))
Предподсчет: 
* Для каждой вершины храним её предков на уровне степени двойки. Для каждой вершинны не более logn памяти (строим табллицу, похожую на sparse table)
* храним глубину

Запрос:
* Выравниваем высоту вершин разбиваем h до степени двойки, ищем p - которая на одном уровне с v (нужно использовать степени двойки, т.к. дерево не бинарное и мб вырождено)

Как разбивать: h  100110 - поднимаемся на те шаги, которые здесь единички, начиная с левого
* Алгоритм поиска похож на бинарный: начинаем с максимума, если он одинаковый - уменьшаем на два, смотрим там. Если разные - это новые u и v

## 2. Решаем LCA с помщью  RMQ (O(nlogn), O(1))
 Делаем Эйлеров обход 
* улитка ползет влево, а потом вправо, каждый раз выписывая индексы всех вершин, которые она обошла (массив а)
* выписывая, параллельно выписываем глубину этих вершин (массив b). строим на этом массиве R(min)Q
* берем отрезок между первым входом u и v в эйлеров обход. Для этого храним массив first - который хранит, где в обходе вершина встречается впервые

*Утверждение*: w = LCA(u, v), b(w) = RMinQ(first(u), first(v))
Доказательство
1. Между парой вершин в дереве ровно 1 путь. И он проходит через вершину w, поэтому он обязательно есть в обходе
2. Почему нет глубины меньшей w? Пусть в пути есть x, h(x) < h(w). Значит, мы выходили из w. По обходу мы каждое ребро проходим ровно 2 раза, значит мы не достигнем u. 
И наоборот (как?)

Определение: f(n), g(n) сведение задачи A -> B (умеем решать В (RMQ), хотим через это решать А(LCA))
1. instane A -> instance B строим структуру (время f(n))
1. quert A -> query B переводим запрос А в В (время g(n))
1. instane A -> instance B переводим ответ А в В (время g(n))

Сведение LCA -> RMG работает за (O(n), O(1)) => умеем решать LCA за (O(nlogn), O(1))

## Сведение RMQ 