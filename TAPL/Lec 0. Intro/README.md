# Что такое типы
Две точки зрения на типы
* Теория типов как раздел математической логики.
* Системы типов для языков программирования.

# Теория типов как раздел математической логики
Первый подход возник значительно раньше, хотя в
современном мире мы впервые сталкиваемся с типами именно
в языках программирования.
## Древний мир: типы для теории множеств (1900 — 1927)

* Уайтхед и Рассел, ветвящаяся теория типов (ramified
theory of types, Whitehead and Russell, 1910). Попытка
исключить логические парадоксы в теории множеств (рекурсию, множества всех множеств и т.д.).
* Ультрапредикативизм: Принцип порочного круга (Vicious
circle principle): никакой объект или свойство не могут
быть определены через использование самого этого
объекта или свойства.

Есть множества, а есть элементы множества. Элемент принадлежит множеству. Подиножество может входить в множество.

А давайте все сделаем множествами. Выразим числа

* 0 = 0'
* 1 = {0'}
* 2 = {0', {0'}}
* 3 = {0, 1, 2}

А теперь можно записать, что 1 входит и принадлежит 2. Множество N подмножество самого себя и само себе принадлежит. Разделим все множества на две группы: одни содержат сами себя в качетсве элемента, а вторые нет.

А что есть множество всех множеств, которые не содержат себя в качестве множеств? Это парадокс

РАссел предложил типизировать и разделить объекты по их уровням
* Критика (Рамсей и Карнап): «Пусть T — самый высокий
человек в комнате». Квантифицироваться можно.
* Ramsey’s simple theory of types (1925) схлопывает
иерархию. Множество всех множест - не очень хорошее понятие, определим его как класс. Тоже имеет свойства, но противоречий меньше.
## Средние века: простые типы для функциональных моделей вычислений (1934 — 1969)
* Шонфинкель и Карри, логика комбинаторов, Сombinatory
logic (Moses Sch¨onfinkel, 1924; Haskell Curry, 1927)
* Черч, бестиповое лямбда-исчисление, Lambda-calculus (Alonzo Church,
1932/33)
* Типизированная логика комбинаторов, (Curry, 1934)
* Simply typed lambda-calculus (Church, 1940).
* Соответствие Карри-Говарда, Curry–Howard correspondence,
(Curry, 1958; Howard, 1969)

Системы типов были заточены под нужды логики
## Новое время: типы как язык для компьютерных систем доказательств (1970 – ...)
комбинатор B: 
это тавтология

тип - это утверждение, теорема
терм соовтетствующего типа - это доказательство. если утверждение тавтология - то есть терм, которые его населяет

modus ponens: a -> b, a |= b

* Зависимые типы: Де Брейн (сделали первый proof checker), AUTOMATH (Nicolas de Bruijn, 1972); Мартин-Лёф (скорее теоретик), Constructive type theory (Per
Martin-Lof, 1973, 1984). Придумали как логику предикатов вложить в систему типов. Даже для предикатов высших порядков.
* Полиморфное лямбда-исчисление: System F (Jean-Yves
Girard, 1970б теоретик) polymorphic lambda-calculus (John Reynolds,
1974б комп саентист). С кванторами над типами.
* Intersection types (M. Coppo, M. Dezani-Ciancaglini, 1978)
* Linear logic (Jean-Yves Girard, 1987)
* Чистые системы типов, pure type systems (Berardi, 1988;
Terlouw, 1989; Barendregt, 1992)
* Гомотопическая теория типов (HoTT), унивалентные
основания математики (Владимир Воеводский, 2005, 2009)

COQ (proof checker), Idris (PL), Agda (PL)

# Системы типов для языков программирования
> Система типов — это гибко управляемый синтаксический метод доказательства отсутствия в программе определенных видов поведения при помощи классификации выражений языка по разновидностям вычисляемых ими значений.  
>Бенджамин Пирс

Т.е. синтаксическое (только на основе кода, без семантики) доказательство того, что поведение запрещено
## Для чего нужны типы в ЯП?
* Выявление некоторых классов ошибок (типа и арность аргументов).
> GHCi> length 42  
> GHCi> foldr (+) "ABCDE"
* Обеспечивают механизм **абстракции**, позволяя отделить
протокол использования от деталей реализации. Т.е. использовать библиотеки не зная реализации, а лишь по сигнатурам.
* Обеспечивают безопасность языка, через механизм целостности абстракций.
* Документация.
* Эффективность.
## Какие бывают системы типов?
Возможны классификации систем типам по разным аспектам. Бестиповых нет вообще хотя бы потому, что данные в памяти хранятся в зависимости от типа
### 1. статические (static) vs динамические (dinamic)
* статические (static) имеют стадию компиляции, на которой ловят ошибки 
* динамические (dinamic) проверяют runtime
### 2. явные (explicit) vs неявные (implicit)
неявные (haskell) выводятся за сценой
### 3. сильные (strong) vs слабые (weak)
есть ли неявные преобразования типов и насколько их много. Если типы изолированы - то сильная, если все приводится друг к другу - система слабая

> В слабой системе это можно типизировать  
> x = 5;  
> y = "37";  
> z = x + y;  
> //результат мб 42 или "537"
### 4. структурные (structural) vs именные (nominal)
лямбда функции не именованые, в хаскеле классы типов именованы, а инстансы нет
### 5. консервативные (conservative) vs выразительные(expressive)
* консервативная - компактная, но отвергает очень много программ
* выразительная позволяет реализовать больше, но язык разрастается (синтаксис типов перегружается). Например, Scala 
## Когда изготавливать систему типов?
Четыре взгляда на функционирование языка
программирования:
* точка зрения прикладного программиста (пишет конечный код, Junior в конторе);
* точка зрения разработчика библиотек и **инфраструктуры** для других разработчиков (Senior/Middle);
* точка зрения разработчиков компиляторов и стандарта существующего языка;
* точка зрения разработчиков нового языка.
Попытки приделать статическую систему типов на уровнях, отличных от последнего, обычно не очень удачны. Исключение - TypeScript.
##
##

