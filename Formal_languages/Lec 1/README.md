 # Формальные языки
### *Алфавит* (сигма ($\Sigma$)) **конечное** произвольное множество
### *Язык* - любое множество слов над некоторым алфавитом 
1. слова конечной длины (в рамках курса)
2. множество слов мб бесконечным
 ## Способы задания языка
 1. Пересичление (только для конечных)
 2. Генератор - черный ящик с корректным для языка словом (пароли, шаблоны для программ)
 3. Распознователь - проверяет, принадлежит ли последовательность языку 


 ## Иерархия Хомского
 
 ## синтаксический анализ (парсинг)
 ## Естественные языки 
 * рнк/днк/белки (вторичные структуры, КС-сжатие - синтаксический анализ данных)
 ## анализ графов
* G = <V, E, L> , V - слова, Е - "соседство", $Е \in U~x~V~x~L$, L - метки на ребрах
* G - ориентированный, конечный
* w(p) = возвращает слово из графа по его пути  p
* |V| = n
 ## Задачи анализа графа
 * поиск путей 
 * поиск кратчайших путей (по какой-то метрике)
 * достижимость

Можно использовать языки как ограничения на пути.

$L_{\Sigma}$ - язык ограничений, $L \in \Sigma$ 

### P - задача поиска путей с ограничениями терминов формальных языков
Хоечется найти такие пути, что полученное слово будет лежать в заданном языке ограничений 
$$P = \{p |\omega (p) \in L_\sigma\}$$
* <> - "обозначает"
* $\pi$ - "существует путь"
$$p <> u_i \pi u_j$$
### Q - задача достижимости 
Достижимость c ограничением ФЯ. Хочу найти все пары вершин, между которыми есть слово из языка
$$Q = \{(u_iu_j) | \exists u_i \pi u_j <> p: w(p) \in L_e \}$$

Задача проще, т.к. ответ всегда конечен

FLPQ

 ## Где применять
 * Графовые бд
* статический анализ кода (граф вызовов ПСП: call - открывающая скобочка, Return - закрывающая. если откуда-то вызвались, то нужно туда вернуться)

CFPQ, CFL-r, Thomas (?)

От графа к 
 ## связь с мл
 GVA - graph variation autoencoding

 синтез белков, химических соединений. если нейронке задать ограничения - ей будет проще генерировать корректные цепочки. ограничения задаются в виде грамматики.
 ## Теория
 * группы, алгебра, топология, теория алгоритмов

 ## Верификация 
 * можно формулировать условия корректности: корректная программа генерирует только определенные последовательности комманд, которые задают "эталонный" язык 
 * настоящая программа тоже выдает последовательности из какого-то языка (как генератор) и он должен быть подмножеством эталонного
 * а как проверить включение одного языка в другой? для общего случая неразрешимо, но можно выделить подкласс, для которого будет разрешимо.

 ## Резюме
 Теория ФЯ и задачи, которые можно с ее помощью решить могут возникать в широких областях.
 # Как устроен курс

 ## Практики
 Будем крутиться вокруг поиска путей в графах с ограничениями в терминах ФЯ, т.к. она более универсальна и применима на практике (и молодая)
 ### Чатик ??
 ### Литература ?? 
 1. 
 2. 
 ### План работы
 * формальные ограничения rpq
 * кс ограничения cfpq
 * мини-среда анализа графов с языком запросов (Graph query language) и простеньких интерпретаторов 
 * будут задачи на эксперименты: сравнить алгоритмы с отчетом на несколько страниц
### Задачи
* будут проверочные работы ~~ контрольные
 * пишем на петоне, тесты должны писать сами
 * табличка с задачами будет в гитхабе
 * алгоритмы решений основаны на матрично-векторных операциях (линал, моноид, кольцо, полукольцо, группа, полугруппа, кронакер, умножение, свойства операций, иденмонетность).
> Зачем? хорошо паралеллится в стандартных либах  
граф - структура нерегулярная, поэтому параллелить их обработку непросто. один из путей - использование линала.  
Граф можно представить в виде матрицы смежности.  
Достаточно большой класс алгоритмов работает с матрицами смежности. Например, поиск транзитивного замыкания, кратчайший путь между всеми парами вершин (тропическое полукольцо).  
Сделали **GraphBLAS**. Эталонная реализация SuiteSparse: Graph BLAS <- Redis Graph
 
 ### Экзамен 
* оценка строится из баллов за оценки, подробнее - на гите
* теоретический экзамен ???

