Деструктор - вызывается сборщиком мусора. Если объект при этом не удаяляется (н-р прост повесить на него ссылку в статический массив)

Констурктор - всегда вызывается при создании объектов (исключение - строковые литералы)
* нет значений по умолчанию, можно из конструктора без параметров вызвать другой конструктор (только на первой строке реализации конструктора)
* всегда вызывается родительский (super)

Наследование 
* множественного нет (избегаем diamond  problem)
* есть интерфейсы
* по дефолту от object наследуется 

Что такое diampnd проблем?
* неправильный ответ: во всех трех есть метод foo и не понятно, какой вызывать (компилятор ругается на это и просит указать явно, какой нужно)
* правильный ответ: поля. поле х есть во все, а в самом нижнем - их два, нужно писать, какой из них не используется.  + методы оперируют разными полями + downcast

Интерфейсы
* все методы по умолчанию public, abstract (без реализации)
* поле по умолчанию public, static, final (константа). Изменить это нельзя
* можно множественнно реализовывать, diamond problem решается явным указанием предка

ЛОЖЬ 
* корректно до 8 java теперь можно писать реализацию методов и статические методы
* в 9 java можно писать приватные методы (чтобы не делать копипасту в реализациях методов)

Абстрактный класс   
класс, который нельзя инстанцировать (с абстрактными методами)

что|interface|abstract class|
--|---|---
поля (состояние)| отсутствуют(только в виде констант), у экземпляров нет состояния | есть
конструкторы | нет. А зачем? В кнструкторах можно делать самоподписку (добавлять ссылку на this в какие-нибудь места| есть

## Модификаторы доступа
Наследование всегда public. 
1. package private   
доступ в пределах пакета. аналог friend. устанавливается по умолчанию (задать явно нельзя). Лучше его не устанавливать! Кто-нибудь со стороны может прийти в пакет и получить доступ к приватным данным.
2. 
3. 
4. 
5. final перед метлами, классами, полями  
* final класс не имеет наследников. Зачем?
* * классы из стандартной библиотеки
* * автобоксинг (нельзя реализовать средствами джава, поэтому доступ к интегеру давать нельзя)
* final методы нельзя изменять в наследниках. Зачем?    
* * раньше: не хотите виртуальные - делайте final, теперь jit сам разберется 
* * инварианты: логика, которую мы не хотим изменять. или некоторые методв могут быть связаны друг с другом и при перегрузке нужно менять оба.
* поля - всегда инициализируются либо в коде, либо в конструкторе
* * константы времени компиляции (int i = 0). могут инлайнится везде при компиляции. к классу обращения может вообще не быть
* * значение, которое инициализируется лишь однажды 
```java
private final int j;
public ctor(){
    j = 12;
    //j = foo();
}
```

